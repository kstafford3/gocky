package gocky

// Parse captures the generated productions or terminal from a generating Production
// A parsed node can be traced through each production back to all generated terminals
//
// A Production describes the structure of a grammar.
// A Parse describes an actual generation from a grammar.
type Parse struct {
	production *Production
	left       *Parse
	right      *Parse
	terminal   string
}

// ProductionTerminals returns each substring representing the provided production key.
// For example, given a production key of "VP", ProductionTerminals will return all terminal combinations that represent a "VP" in this parse.
func (p *Parse) ProductionTerminals(productionKey string) [][]string {
	matchingSubparses := p.Subparses(productionKey)
	terminalRepresentations := [][]string{}
	for _, matchingSubparse := range matchingSubparses {
		terminalRepresentations = append(terminalRepresentations, nodeTerminals(matchingSubparse)...)
	}
	return terminalRepresentations
}

// Subparses retrieves "subtrees" within the parse that were produced by the given production
// For example, given a production key of "VP", subtrees generated by the "VP" production will be returned.
// Returned subtrees will also be searched for matching productions, different parts of the same tree could be returned
func (p *Parse) Subparses(productionKey string) []*Parse {
	return traverseToKey(p, productionKey)
}

// ProductionKeys retrieves the key of every production within the parse
func (p *Parse) ProductionKeys() []string {
	productionKeys := []string{p.production.key}
	if p.left != nil {
		productionKeys = append(productionKeys, p.left.ProductionKeys()...)
	}
	if p.right != nil {
		productionKeys = append(productionKeys, p.right.ProductionKeys()...)
	}
	return productionKeys
}

// traverseToKey traverses the Parse tree to find component Parses that match the given production key
func traverseToKey(node *Parse, productionKey string) []*Parse {
	if node == nil {
		return []*Parse{}
	}
	leftMatches := traverseToKey(node.left, productionKey)
	rightMatches := traverseToKey(node.right, productionKey)
	matches := append(leftMatches, rightMatches...)
	if node.production.key == productionKey {
		matches = append(matches, node)
	}
	return matches
}

// nodeTerminals collects the terminals for a given Parse
func nodeTerminals(node *Parse) [][]string {
	if node == nil {
		return [][]string{}
	}
	if len(node.terminal) > 0 {
		return [][]string{
			[]string{node.terminal},
		}
	}
	leftTerminals := nodeTerminals(node.left)
	rightTerminals := nodeTerminals(node.right)
	terminalCombinations := [][]string{}
	for _, leftTerminal := range leftTerminals {
		for _, rightTerminal := range rightTerminals {
			combination := append(leftTerminal, rightTerminal...)
			terminalCombinations = append(terminalCombinations, combination)
		}
	}
	return terminalCombinations
}
